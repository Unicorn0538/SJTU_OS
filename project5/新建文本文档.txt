一、Design a threadpool
1、设计思路
基本的框架教材源代码已有，基本思路就是在主函数中将创建的任务利用队列提交到线程池中执行。如果没有可用线程，则任务将一直排队，直到线程可用。
1）client.c：该文件中主要是main（）函数的实现，通过读取键盘输入的任务数量，然后创建任务，因为线程只设置了10个，因此在提交时，当线程满了的时候，就会使得main函数进入休眠状态，等一段时间后，再次提交接下来的10个任务，直到所有任务都被提交到线程池。然后休眠一段状态，退出任务执行。
2）threadpool.c/threadpool.h:
头文件中主要是函数和信号量的定义。.c文件中是函数的实现
pool_init和pool_submit主要是线程的创建和将任务提交到进程之中。
equeue（）和dequeue（）是将任务插入和读出，模拟线程池的管理。在读取和插入的时候，要设置互斥锁，防止读取和插入发生冲突。
worker（）和execute（）主要是任务的执行，在执行时，信号量sem_wait(&semlock)。

2、实验效果
 
3、实验讨论
在worker（）函数中执行时，自己在等待信号量之后加了互斥锁，使用了与队列中相同的锁变量，以至于发生锁死，最后直接选择了去除这个互斥锁，因为已经有了sem_wait().
二、The Producer – Consumer Problem
1、设计思路
基本代码的框架在教材上已经有，基本思路是读取传递的参数，然后依照参数设置生产者和消费者的线程数量，以及主函数的休眠的时间，在休眠时间内生产者和消费者进出缓存区，休眠时间结束，主函数结束进程。
1)main.c:
main():判断参数的传递是否正确，然后初始化信号量和锁变量。然后由传递进来的参数创建消费者进程和生产者进程。在根据传递进来的第一个参数设置主进程的休眠时间。等休眠时间结束，主函数结束进程并退出程序。
producer()/consumer()：主要模拟生产者和消费者的实现过程，producer调用insert_item（）函数将随机生成的item放进缓存区，consumer调用remove_item()函数将缓存区中的数读出。
2)buffer.h/buffer.c
主要是信号量的定义，以及以下两个函数的实现
insert_item()/remove_item():在插入和去除缓存区的时候，加上信号量判断缓存区是否已满/空，并且加上互斥锁，避免消费者和生产者造成冲突。
2、实验效果
 
3、实验讨论
由上图可以看出，当生产者消费者的线程增多时，在短时间可以进出缓存区的次数明显增多。

参考：
	教材源代码下载：https://github.com/greggagne/osc10e/tree/master/ch7
	线程同步值信号量：https://www.cnblogs.com/zhengAloha/p/8665719.html
	POSIX多线程设计：				 	https://www.cnblogs.com/mywolrd/archive/2009/02/05/1930707.html
	生产者消费者模型：		https://blog.csdn.net/liushall/article/details/81569609
