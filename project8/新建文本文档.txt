一设计思路
基本思路就是按照虚拟内存的管理，首先将得到的整数进行处理，如下图，得到page number和offset。
 

然后根据page number寻找frame number。查找方法如下图。首先查找TLB，若TLB没有，在查找page table，若还是没有，就从文件BACKING_STORE.bin中取出数据，存入物理内存，并更新page　table和ＴＬＢ。
 
地址数据的保存是由结构体ADDRESS构成，其中包含逻辑地址，物理地址和读取到的数据。
TLB是由结构体ｔｌｂ保存，其中含有逻辑地址和物理地址的页码和是否失效的标记。
Page　table　是由结构体PAGE_TABLE保存，其中含有逻辑地址和物理地址的页码和是否失效的标记。
物理内存是由二维数组physical＿memory［］［］保存。
main（）：ｍａｉｎ函数主要是做打开文件和读取文件数据的作用。
ｇｅｔ＿physical（）：该函数首先计算出逻辑地址的页码和偏移量。然后根据页码首先在ＴＬＢ中查找是否命中，命中则在命中计数加一，并根据得到的帧号读取值保存，并计算出物理地址。否则查找page　table，若命中调用update＿TLB（）函数更新TLB。若页缺失，则根据页号更新物理内存和页表，更新方式是FIFO（加两个全局变量计数值，每次余页表的值和内存页帧数量的值，并加一），然后再更新ＴＬＢ，更新方式也是FIFO。
update（）：更新物理内存和页表，更新方式为FIFO
update＿TLB（）：更新TLB，更新方式为FIFO

二、实验结果
部分正确答案（OS_github获得）：
 

本人实验结果：
 

部分正确答案：
 

本人实验结果（物理地址空间为256个页帧）：
 
本人实验结果（物理地址空间为128个页帧）：
 
三、讨论
１）TLB和page＿table，刚开始没有在结构体中加有效标记valid。后来加上是考虑提高时间效率，因为在页表没有被更新的时候，只需要判断valid是否等于１。而没有加的的时候，需要判断两个变量值是否相等，而且一个变量没有初始化，会使得时间消耗增多。
２）由实验结果可以看到在减小物理内存空间和页表一半的时候，对TLB的命中率没有影响，而页面缺失率增加２倍多。可知页表和物理内存空间越大，页面缺失率就就会相对减少。
参考：
	OS教材第十版
	相关数据下载：https://github.com/greggagne/osc10e/tree/master/ch10
	FILE文件流的使用：		https://www.cnblogs.com/Romi/archive/2012/02/29/2374769.html
	

