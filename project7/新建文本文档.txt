一、设计思路
数据由一个结构体保存，将每一个分区的name、起始地址和终止地址记录在一个结构体内部，依照起始地址的大小将其排列在数组中。
main():在main函数中读取传递的数据存储。然后设置条件转移，当读取到命令时，根据命令调用相应的函数。
insert():该函数是在分配空间时进行插入操作，传入的参数中有序号k，则将block中将第k位及之后的分区后移一位，然后将该分区设置为第k位。并将size加一
request():该函数是进行块的分配，首先将每两个块之间没有用到的分区大小计算出来，保存到block_tmp中，然后根据不同的算法寻找插入的序列号，调用insert进行插入。worst算法就是找到block_tmp中最大的一个分块。First算法是找到第一个比需要分配的空间大的分块。best是找到最合适的分块。
release():该函数是释放空间的函数，释放空间时，只需要找到需要释放的序号，然后将后面的block前移一位，覆盖住这个分块。并将size减一。
compat():该函数是合并空间的函数，在从头到尾遍历一遍，将每个分块的起始地址都设置为前一位的终止地址加一，就可以起到合并的作用。
二、实验结果
 
 
输入的命令为：
$gcc C.c
$./a.out 1035426
$
	RQ P1 1024 W
	RQ P2 1024 W
	RQ P3 1024 W
	RQ P4 1024 W
	STAT
	RL P1
	RL P3
	STAT
	RQ P5 1024 F
	STAT
	RQ P6 1024 B
	STAT
	RL P6
	RQ 1024 P7 W
	STAT
	C
	STAT
	X
两条横线之间为此时的分区范围。
三、讨论
	本程序总体来说比较简单，难点在于数据的保存和其中的细节。我自己采用的结构体加数组的形式。同时在数组的第一个将起始地址和终止地址都设置为0，会使得后面的代码省去很多，就不用单独判别第一位的其实地址是否为0的情况。另外由于，一些细节的不注意，尤其是数组的大小和空间的大小计算问题，导致最后bug很多。
参考：
	OS教材第十版
