一、MultiThread
1、实现思路：
由教材知识可知，首先将输入的字符串argv，保存为数组array，得到其长度count。然后定义子进程，由于需要两个单独的子进程去完成排序，所以定义两个子进程tid1，tid2。利用函数pthread_create(&tid,&attr,&sort_first,array)分别取调用两个排序的函数sort_first和sort_second将数组的两部分进行排序。每个进程依次完成，其中pthread_join(tid,NULL)会使得父进程等待子进程的执行。两个子进程依次执行完毕之后。父进程中再调用Merge_Array()函数将两组排序好的数据进行合并。
2、实验结果：
编译：$gcc -g C.c -o C -lpthread
运行：$./C 7 12 19 3 18 4 2 6 15 8
 
3、问题：
1）对数组的设置，刚开始时，直接在main（）函数中将数组设置为了固定，后来又在网上查阅资料，发现main（int argc,char**argv）的参数可以在编译的时候进行传递，argc代表输入的长度，argv是字符串的保存，所以改用了动态。
2）编译的时候，make命令的编写刚开始没有加-lpthread.导致每次编译都会出现进程没有申明，多次检查无果之后，在网上查资料才发现子进程的编译是需要在最后加-lpthread

二、Fork-Join Sorting Application
1、实现思路（以MergeSort为例）
1）数列的输入：数列的输入的时候采用Scanner类，将键盘输入的由空格分开的整数字符串转换为整数数组，实现动态输入。
2）判断数组的规模大小，若数据规模小于MaxSize=10，采用选择排序（直接在父进程中进行）。否则采用多线程的MergeSort实现，定义线程池，定义扩展类的对象，然后实现排序。
3）定义RecursiveAction的扩展类Sort_merge。基本的定义教材上有。主要是compute函数。取数组规模的中间值，然后将数组分为两部分，分别去调用扩展类。之前在main函数中定义了进程池，在这里调用函数invokeAll（），则父进程将会等待子进程完成程序之后，进行调用merge将排序好的两部分进行组合。
4)在Quick_sort中的实现和上述类似，除了最后改变其排序的方式。
2、实验结果
编译：$javac Merge_sort.java
运行：$java Merge_sort
输入所需要排序的数....
 
3、问题
1）因为这是第一次接触java所以很多基础知识需要掌握，碰到的问题中最难是编译，刚开始，在题目中，设置了多个公共类，而且java文件的名称和公共类的名称不相同，导致多次编译运行不通过。
2）在compute中调用类中的设置的公共变量arr，没有问题，但是在自己定义的函数中如果会出现更改arr数组中的情况，则会显示静态变量不可更改的情况。所以在函数调用的时候直接进行了参数传递。

